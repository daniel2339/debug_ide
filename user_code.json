{
    "code": "#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <limits>\n#include <set>\n#include <utility>\n#include <vector>\n\nusing Vertex    = std::uint16_t;\nusing Cost      = std::uint16_t;\nusing Edge      = std::pair< Vertex, Cost >;\nusing Graph     = std::vector< std::vector< Edge > >;\nusing CostTable = std::vector< std::uint64_t >;\n\nconstexpr auto kInfiniteCost{ std::numeric_limits< CostTable::value_type >::max() };\n\nauto dijkstra( Vertex const start, Vertex const end, Graph const & graph, CostTable & costTable )\n{\n    std::fill( costTable.begin(), costTable.end(), kInfiniteCost );\n    costTable[ start ] = 0;\n\n    std::set< std::pair< CostTable::value_type, Vertex > > minHeap;\n    minHeap.emplace( 0, start );\n\n    while ( !minHeap.empty() )\n    {\n        auto const vertexCost{ minHeap.begin()->first  };\n        auto const vertex    { minHeap.begin()->second };\n\n        minHeap.erase( minHeap.begin() );\n\n        if ( vertex == end )\n        {\n            break;\n        }\n\n        for ( auto const & neighbourEdge : graph[ vertex ] )\n        {\n            auto const & neighbour{ neighbourEdge.first };\n            auto const & cost{ neighbourEdge.second };\n\n            if ( costTable[ neighbour ] > vertexCost + cost )\n            {\n                minHeap.erase( { costTable[ neighbour ], neighbour } );\n                costTable[ neighbour ] = vertexCost + cost;\n                minHeap.emplace( costTable[ neighbour ], neighbour );\n            }\n        }\n    }\n\n    return costTable[ end ];\n}\n\nint main()\n{\n    constexpr std::uint16_t maxVertices{ 10000 };\n\n    Graph     graph    ( maxVertices );\n    CostTable costTable( maxVertices );\n\n    std::uint16_t testCases;\n    std::cin >> testCases;\n\n    while ( testCases-- > 0 )\n    {\n        for ( auto i{ 0 }; i < maxVertices; ++i )\n        {\n            graph[ i ].clear();\n        }\n\n        std::uint16_t numberOfVertices;\n        std::uint16_t numberOfEdges;\n\n        std::cin >> numberOfVertices >> numberOfEdges;\n\n        for ( auto i{ 0 }; i < numberOfEdges; ++i )\n        {\n            Vertex from;\n            Vertex to;\n            Cost   cost;\n\n            std::cin >> from >> to >> cost;\n            graph[ from ].emplace_back( to, cost );\n        }\n\n        Vertex start;\n        Vertex end;\n\n        std::cin >> start >> end;\n\n        auto const result{ dijkstra( start, end, graph, costTable ) };\n\n        if ( result == kInfiniteCost )\n        {\n            std::cout << \"NO\\n\";\n        }\n        else\n        {\n            std::cout << result << '\\n';\n        }\n    }\n\n    return 0;\n}\n"
}